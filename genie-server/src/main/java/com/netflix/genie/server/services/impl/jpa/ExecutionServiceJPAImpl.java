/*
 *
 *  Copyright 2015 Netflix, Inc.
 *
 *     Licensed under the Apache License, Version 2.0 (the "License");
 *     you may not use this file except in compliance with the License.
 *     You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
 *
 */
package com.netflix.genie.server.services.impl.jpa;

import com.netflix.client.http.HttpRequest;
import com.netflix.client.http.HttpRequest.Verb;
import com.netflix.config.ConfigurationManager;
import com.netflix.genie.common.client.BaseGenieClient;
import com.netflix.genie.common.exceptions.GenieConflictException;
import com.netflix.genie.common.exceptions.GenieException;
import com.netflix.genie.common.exceptions.GenieNotFoundException;
import com.netflix.genie.common.exceptions.GeniePreconditionException;
import com.netflix.genie.common.exceptions.GenieServerException;
import com.netflix.genie.common.exceptions.GenieServerUnavailableException;
import com.netflix.genie.common.model.Job;
import com.netflix.genie.common.model.JobStatus;
import com.netflix.genie.common.util.ProcessStatus;
import com.netflix.genie.server.jobmanager.JobManagerFactory;
import com.netflix.genie.server.metrics.GenieNodeStatistics;
import com.netflix.genie.server.metrics.JobCountManager;
import com.netflix.genie.server.repository.jpa.JobRepository;
import com.netflix.genie.server.repository.jpa.JobSpecs;
import com.netflix.genie.server.services.ExecutionService;
import com.netflix.genie.server.services.JobService;
import com.netflix.genie.server.util.NetUtil;
import org.apache.commons.configuration.AbstractConfiguration;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.validator.constraints.NotBlank;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;

import javax.validation.ConstraintViolationException;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import java.io.IOException;
import java.util.Date;
import java.util.List;

/**
 * Implementation of the Genie Execution Service API that uses a local job
 * launcher (via the job manager implementation), and uses OpenJPA for
 * persistence.
 *
 * @author skrishnan
 * @author bmundlapudi
 * @author amsharma
 * @author tgianos
 */
public class ExecutionServiceJPAImpl implements ExecutionService {

    private static final Logger LOG = LoggerFactory.getLogger(ExecutionServiceJPAImpl.class);

    // instance of the netflix configuration object
    private static final AbstractConfiguration CONF;

    // these can be over-ridden in the properties file
    private static final int SERVER_PORT;
    private static final String JOB_RESOURCE_PREFIX;

    // initialize static variables
    static {
        //TODO: Seem to remember something about injecting configuration using governator
        CONF = ConfigurationManager.getConfigInstance();
        SERVER_PORT = CONF.getInt("netflix.appinfo.port", 7001);
        JOB_RESOURCE_PREFIX = CONF.getString(
                "com.netflix.genie.server.job.resource.prefix", "genie/v2/jobs");
    }

    // per-instance variables
    private final GenieNodeStatistics stats;
    private final JobRepository jobRepo;
    private final JobCountManager jobCountManager;
    private final JobManagerFactory jobManagerFactory;
    private final JobService jobService;

    /**
     * Default constructor - initializes persistence manager, and other utility
     * classes.
     *
     * @param jobRepo           The job repository to use.
     * @param stats             the GenieNodeStatistics object
     * @param jobCountManager   the job count manager to use
     * @param jobManagerFactory The the job manager factory to use
     * @param jobService        The job service to use.
     */
    public ExecutionServiceJPAImpl(
            final JobRepository jobRepo,
            final GenieNodeStatistics stats,
            final JobCountManager jobCountManager,
            final JobManagerFactory jobManagerFactory,
            final JobService jobService) {
        this.jobRepo = jobRepo;
        this.stats = stats;
        this.jobCountManager = jobCountManager;
        this.jobManagerFactory = jobManagerFactory;
        this.jobService = jobService;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Job submitJob(
            @NotNull(message = "No job entered to run")
            @Valid
            final Job job
    ) throws GenieException {
        LOG.debug("Called");
        if (StringUtils.isNotBlank(job.getId()) && this.jobRepo.exists(job.getId())) {
            throw new GenieConflictException("Job with ID specified already exists.");
        }

        // Check if the job is forwarded. If not this is the first node that got the request.
        // So we log it, to track all requests.
        if (!job.isForwarded()) {
            LOG.info("Received job request:" + job);
        }

        // Queueing: make jobs queue up if over the system-wide limit.  Alternative to dealing
        // with the HTTP 503's and the never-ending space/memory issues.
        final int maxSystemJobs = CONF.getInt("com.netflix.genie.server.max.system.jobs", 1000);

        if (this.jobCountManager.getNumRunningJobs() < maxSystemJobs) {
            final Job forwardedJob = checkAbilityToRunOrForward(job);

            if (forwardedJob != null) {
                return forwardedJob;
            }

            // At this point we have established that the job can be run on this node.
            // Before running we validate the job and save it in the db if it passes validation.
            final Job savedJob = this.jobService.createJob(job);

            // try to run the job - return success or error
            return this.jobService.runJob(savedJob);
        } else {
            final Job savedJob = this.jobService.queueJob(job);
            LOG.info("Queued and saved job with id: " + job.getId());
            return savedJob;
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional(
            rollbackFor = {
                    GenieException.class,
                    ConstraintViolationException.class
            }
    )
    public Job killJob(
            @NotBlank(message = "No id entered unable to kill job.")
            final String id
    ) throws GenieException {
        LOG.debug("called for id: " + id);
        final Job job = this.jobRepo.findOne(id);

        // do some basic error handling
        if (job == null) {
            throw new GenieNotFoundException("No job exists for id " + id + ". Unable to kill.");
        }

        // check if it is done already
        if (job.getStatus() == JobStatus.SUCCEEDED
                || job.getStatus() == JobStatus.KILLED
                || job.getStatus() == JobStatus.FAILED) {
            // job already exited, return status to user
            return job;
        } else if (job.getStatus() == JobStatus.INIT
                || job.getProcessHandle() == -1) {
            // can't kill a job if it is still initializing
            throw new GeniePreconditionException("Unable to kill job as it is still initializing");
        }

        // if we get here, job is still running - and can be killed
        // redirect to the right node if killURI points to a different node
        final String killURI = job.getKillURI();
        if (StringUtils.isBlank(killURI)) {
            throw new GeniePreconditionException("Failed to get killURI for jobID: " + id);
        }
        final String localURI = getEndPoint() + "/" + JOB_RESOURCE_PREFIX + "/" + id;

        if (!killURI.equals(localURI)) {
            LOG.debug("forwarding kill request to: " + killURI);
            return forwardJobKill(killURI);
        }

        // if we get here, killURI == localURI, and job should be killed here
        LOG.debug("killing job on same instance: " + id);
        this.jobManagerFactory.getJobManager(job).kill();

        job.setJobStatus(JobStatus.KILLED, "Job killed on user request");
        job.setExitCode(ProcessStatus.JOB_KILLED.getExitCode());

        // increment counter for killed jobs
        this.stats.incrGenieKilledJobs();

        LOG.debug("updating job status to KILLED for: " + id);
        if (!job.isDisableLogArchival()) {
            job.setArchiveLocation(NetUtil.getArchiveURI(id));
        }

        // all good - return results
        return job;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public int markZombies() {
        LOG.debug("called");
        final ProcessStatus zombie = ProcessStatus.ZOMBIE_JOB;
        final long currentTime = new Date().getTime();
        final long zombieTime = CONF.getLong("com.netflix.genie.server.janitor.zombie.delta.ms", 1800000);

        @SuppressWarnings("unchecked")
        final List<Job> jobs = this.jobRepo.findAll(
                JobSpecs.findZombies(currentTime, zombieTime)
        );
        for (final Job job : jobs) {
            job.setStatus(JobStatus.FAILED);
            job.setFinished(new Date());
            job.setExitCode(zombie.getExitCode());
            job.setStatusMsg(zombie.getMessage());
        }
        return jobs.size();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JobStatus finalizeJob(
            @NotBlank(message = "No job id entered. Unable to finalize.")
            final String id,
            final int exitCode
    ) throws GenieException {
        // NOTES: breaking the parts of this up into their own transaction took some careful
        // steps: 1) can't call protected/private methods as they are not made transactional, and
        // 2) calling methods on the same class doesn't go through Spring's proxied objects and so
        // transactions are not enforced.  Solution was to pull out finalizeJobStatus and move
        // it to the JobService instead.  Now this method is analogous to submitJob, as it
        // also calls transactional methods on JobService

        // Finalize the job status of the completed job in its own transaction
        JobStatus returnStatus = this.jobService.finalizeJobStatus(id, exitCode);

        // Attempt to release a queued job if one exists.  Although this is a side-effect, it's the
        // best place to do it since we know we've got a slot free.  However we don't want this to
        // stop finalizeJob so catch exceptions and log them here.  The alternative is to have a
        // thread on each node that periodically releases queued jobs, but that creates additional
        // complexity that we might not need or want.
        try {
            final int maxSystemJobs = CONF.getInt("com.netflix.genie.server.max.system.jobs", 1000);

            LOG.debug("Checking if we should release a queued job.");
            if (this.jobCountManager.getNumRunningJobs() < maxSystemJobs) {
                // Retrieve and release a queued job in one transaction
                final Job releasedJob = this.jobService.unQueueOldestJob();
                if (releasedJob != null) {
                    LOG.info("Found and released oldest queued job with id : " + releasedJob.getId());

                    // Perform other prep (attachments, etc) that occur outside of a DB transaction then run job
                    final Job jobToRun = this.jobService.prepUnqueuedJob(releasedJob);
                    // Finally, run the job (separate transaction)
                    this.jobService.runJob(jobToRun);
                }
            }
        } catch (final GenieException ex) {
            LOG.error("Exception when trying to unqueue a job, this will not fail finalizeJob.", ex);
        }

        return returnStatus;
    }


    private String getEndPoint() throws GenieException {
        return "http://" + NetUtil.getHostName() + ":" + SERVER_PORT;
    }

    private Job forwardJobKill(final String killURI) throws GenieException {
        try {
            final BaseGenieClient client = new BaseGenieClient(null);
            final HttpRequest request = BaseGenieClient.buildRequest(Verb.DELETE, killURI, null, null);
            return (Job) client.executeRequest(request, null, Job.class);
        } catch (final IOException ioe) {
            throw new GenieServerException(ioe.getMessage(), ioe);
        }
    }

    private Job forwardJobRequest(
            final String hostURI,
            final Job job) throws GenieException {
        try {
            final BaseGenieClient client = new BaseGenieClient(null);
            final HttpRequest request = BaseGenieClient.buildRequest(Verb.POST, hostURI, null, job);
            return (Job) client.executeRequest(request, null, Job.class);
        } catch (final IOException ioe) {
            throw new GenieServerException(ioe.getMessage(), ioe);
        }
    }

    /**
     * Check if we can run the job on this host or not.
     *
     * @throws GenieException
     */
    private synchronized Job checkAbilityToRunOrForward(
            final Job job) throws GenieException {
        // ensure that job won't overload system
        // synchronize until an entry is created and INIT-ed in DB
        // throttling related parameters
        final int maxRunningJobs = CONF.getInt(
                "com.netflix.genie.server.max.running.jobs", 0);
        final int jobForwardThreshold = CONF.getInt(
                "com.netflix.genie.server.forward.jobs.threshold", 0);
        final int maxIdleHostThreshold = CONF.getInt(
                "com.netflix.genie.server.max.idle.host.threshold", 0);
        final int idleHostThresholdDelta = CONF.getInt(
                "com.netflix.genie.server.idle.host.threshold.delta", 0);

        final int numRunningJobs = this.jobCountManager.getNumInstanceJobs();
        LOG.info("Number of running jobs: " + numRunningJobs);

        // find an instance with fewer than (numRunningJobs -
        // idleHostThresholdDelta)
        int idleHostThreshold = numRunningJobs - idleHostThresholdDelta;
        // if numRunningJobs is already >= maxRunningJobs, forward
        // aggressively
        // but cap it at the max
        if (idleHostThreshold > maxIdleHostThreshold
                || numRunningJobs >= maxRunningJobs) {
            idleHostThreshold = maxIdleHostThreshold;
        }

        // check to see if job should be forwarded - only forward it
        // once. the assumption is that jobForwardThreshold < maxRunningJobs
        // (set in properties file)
        if (numRunningJobs >= jobForwardThreshold && !job.isForwarded()) {
            LOG.info("Number of running jobs greater than forwarding threshold - trying to auto-forward");
            final String idleHost = this.jobCountManager.getIdleInstance(idleHostThreshold);
            if (!idleHost.equals(NetUtil.getHostName())) {
                job.setForwarded(true);
                this.stats.incrGenieForwardedJobs();
                return forwardJobRequest("http://" + idleHost + ":"
                        + SERVER_PORT + "/" + JOB_RESOURCE_PREFIX, job);
            } // else, no idle hosts found - run here if capacity exists
        }

        // TODO: Gotta be something better we can do than this
        if (numRunningJobs >= maxRunningJobs) {
            // if we get here, job can't be forwarded to an idle
            // instance anymore and current node is overloaded
            throw new GenieServerUnavailableException(
                    "Number of running jobs greater than system limit ("
                            + maxRunningJobs
                            + ") - try another instance or try again later");
        }

        //We didn't forward the job so return null to signal to run the job locally
        return null;
    }
}
